import java.util.Scanner;

public class main {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n=in.nextInt(),i=0,j=0,x,Ncon,k=-1,x1,x2,S; // количество устр. задаеться здесь(n)
		int a[][];
		byte c[],c_cop[];
		boolean L=true,M=true;
		a= new int[n][]; // БАЗА ДАННЫХ
		c= new byte[n];  // филтрующий массив в который заноситься "путь"
 		c_cop= new byte[n]; //копия филтрующего массива (нет)
 		
 		/*
 		//ручной ввод
		for (i=0;i<n;i++) {             //вводим значения в массив
			x=in.nextInt();
			a[i]= new int[x+1];
			a[i][0]= x;
			for (j=1;j<x+1;j++)       // в 0 элементе лежит количество возможных соединений
				a[i][j]=in.nextInt();
		}
		Ncon=in.nextInt()-1; // задаем АА
		c[in.nextInt()-1]=1; // задаем ВВ как крайнию точку в филтрруещем массиве
		//конец
		*/
		
 		//рандомный ввод
 		for (i=0;i<n;i++) {             //вводим значения в массив
			x=(int) (Math.random()*(n-1)+1);
			a[i]= new int[x+1];
			a[i][0]= x;
			for (j=1;j<x+1;j++)       // в 0 элементе лежит количество возможных соединений
				a[i][j]=(int) (Math.random()*(n-1)+1);
			}
 		for (i=0;i<n;i++) {
 			System.out.print((i+1)+(i+1>9?"   ":"    "));//номер устройства
 			for (x1=0;x1<a[i][0]+1;x1++)
 				System.out.print((a[i][x1])+(a[i][x1]>9?" ":"  "));
 			System.out.println();
 		}
 		Ncon=(int) (Math.random()*(n-2)+1); // задаем АА
 		x1=(int) (Math.random()*(n-2)+1);
		c[x1]=1; // задаем ВВ как крайнию точку в филтрруещем массиве
		System.out.println();
		System.out.println((Ncon+1)+"  "+(x1+1));
		System.out.println();
		System.out.println();
		// конец
		
		while(L) {
			for (i=0;i<n;i++) 
				if (c[i] ==1) // ищим крайнию точку в филтрруещем массиве
					for (j=0;j<n;j++)
						if (c[j] ==0) // ищим точки до которых мы еще не дошли
							for (x2=1;x2<a[j][0]+1;x2++)
								for(x1=1;x1<a[i][0]+1;x1++)
									if(a[i][x1] == a[j][x2]) //проверяем можем ли мы до них дойти
										c_cop[j]=1;  //если можем, записываем их в "транспортный массив"
			for (i=0;i<n;i++)
				if(c[i]>0)
					c[i]++;     // обнавляем старые данные (что прошли на точку дальше) 
			for (i=0;i<n;i++) 
				if (c_cop[i] ==1) {
					c_cop[i]=0;
					c[i]=1;     // вносим новые крайние точки и очищаем "транспортный массив"
				}               // ps: ранше эти данные мешали бы нормальной работе цикла
			if (c[Ncon]>0)
				L=false;        // проверяем не дошли ли мы до нужной точки
			k++;                // увеличиваем счечик дуйствий
			for (i=0;i<n;i++)
				if (c[i]==1) {  // проверяем есть ли крайние точки в филтрруещем массиве
					M=true;     // если есть продолжаем работать
					break;      // если нет значит мы встали в край того куда можем дойти
				} else M=false; // значит обрываем работу цикла 
			if (!M) {
				k=-1;           // и говрим что k=-1
				L=false;        
			}
		}
		System.out.println(k);
		S=Ncon;                 // вспомогательная данная 
		for(i=2;i<k+2;i++) {    // в этом цикле мы просматриваем можем ли мы итди по этому пути
			ll:                 // если да то идем если нет то смотрим на другие пути
			for(j=0;j<n;j++)    // ps: хотя бы один правильный путь есть
		 	 	if(c[j]==i) 
		 	 		for (x2=1;x2<a[j][0]+1;x2++)
						for(x1=1;x1<a[S][0]+1;x1++)
							if(a[S][x1] == a[j][x2]) {
								 System.out.print(j+1+" ");
								 S=j;
								 break ll;
							}
		}
	}

}
